<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
"http://www.w3.org/TR/html4/strict.dtd">

<html lang="en">
<head>
  <title>Books by Ian Parberry</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <link rel="stylesheet" type="text/css" href="../parberry.css">
  <link rel="stylesheet" type="text/css" href="../menu.css">
  <script type="text/javascript" src="../menu.js"></script>
</head>

<body>
  <script type="text/javascript">
    MenuBar();
  </script>

  <h1>Books by Ian Parberry</h1>

  <h2>Introduction to Game Physics with Box2D (2013)</h2>

  <div class=content>
    <img class="centered" src="gamephysics/images/gamephysicsstrip.png" alt="Thumbnails.">

    <p>
      <a href="/">Ian Parberry</a>,
      <em>Introduction to Game Physics with Box2D</em>,
      <a href="http://www.akpeters.com/">AK Peters Publishers</a>, 2013.
      [<a href="gamephysics">More Information</a>]
    </p>
  </div>

  <h2>3D Math Primer for Graphics and Game Development 2e (2011)</h2>

  <div class=content>
    <img class="centered" src="3dmathprimer/images/primer2strip.jpg" alt="Thumbnails.">
    <p>
      Fletcher Dunn and <a href="/">Ian Parberry</a>,
      <em>3D Math Primer for Graphics and Game Development</em>,
      2nd Edition, A.K. Peters, 2011.
      [<a href="3dmathprimer">More Information</a>]
    </p>
  </div>


<h2>3D Math Primer for Graphics and Game Development (2002)</h2>

<div class=content>
<img alt="Primer 1e strip." class=centered src="3dmathprimer/images/primer1strip.jpg">
<p>

Fletcher Dunn and
<a href="/">Ian Parberry</a>, 
<em>3D Math Primer for Graphics and Game Development</em>, Wordware Publishing, 2002.
<p>

<h3>From the Introduction</h3>

If you want to learn about 3D math in order to program games or graphics, then this book is for
you. There are many books out there that promise to teach you how to make a game or put cool
pictures up on the screen, so why should you read this particular book? This book offers several
unique advantages over other books about games or graphics programming:
<ul>
<li>
<b>A unique topic.</b> This book fills a gap that has been left by other books on graphics, linear
algebra, simulation, and programming. It is an introductory book, meaning we have focused
our efforts on providing thorough coverage on fundamental 3D concepts - topics that are
normally glossed over in a few quick pages or relegated to an appendix in other publications
(because, after all, you already know all this stuff). Our book is definitely the book you should
read first, before buying that "Write a 3D Video Game in 21 Days" book. This book is not only
an introductory book, it is also a reference book - a "toolbox" of equations and techniques
that you can browse through on a first reading and then revisit when the need for a specific
tool arises.
<li>
<b>A unique approach.</b> We take a three-pronged approach to the subject matter: math, geometry,
and code. The math part is the equations and numbers. This is where most books stop. Of
course, the math is important, but to make it powerful, you have to have good intuition about
how the math connects with the geometry.We will show you not just one but multiple ways to
relate the numbers with the geometry on a variety of subjects, such as orientation in 3D,
matrix multiplication, and quaternions. After the intuition comes the implementation; the
code part is the practical part.We show real usable code that makes programming 3D math as
easy as possible.
<li>
<b>Unique authors.</b> Our combined experience brings together academic authority with
in-the-trenches practical advice. Fletcher Dunn has six years of professional game programming
experience and several titles under his belt on a variety of gaming platforms. He is currently
employed as the principal programmer at Terminal Reality and is the lead programmer
on BloodRayne.Dr. Ian Parberry has 18 years of experience in research and teaching in academia.
This is his sixth book, his third on game programming. He is currently a tenured full professor
in the Department of Computer Sciences at the University of North Texas. He is
nationally known as one of the pioneers of game programming in higher education and has
been teaching game programming to undergraduates at the University of North Texas since
1993.
<li>
<b>Unique pictures.</b> You cannot learn about a subject like 3D by just reading text or looking at
equations. You need pictures, and this book has plenty of them. Flipping through, you will
notice that in many sections there is one on almost every page. In other words, we don't just
tell you something about 3D math, we show you. You'll also notice that pictures often appear
beside equations or code. Again, this is a result of our unique approach that combines mathematical
theory, geometric intuition, and practical implementation.
<li>
<b>Unique code.</b> Unlike the code in some other books, the classes in this book are not designed
to provide every possible operation you could ever want. They are designed to perform specific
functions very well and to be easy to understand and difficult to misuse. Because of their
simple and focused semantics, you can write a line of code and have it work the first time,
without twiddling minus signs, swapping sines and cosines, transposing matrices, or otherwise
employing "random engineering" until it looks right. Many other books exhibit a common
class design flaw of providing every possible operation when only a few are actually
useful.
<li>
<b>A unique writing style.</b>
Our style is informal and entertaining, but formal and precise when
clarity is important. Our goal is not to amuse you with unrelated anecdotes, but to engage you
with interesting examples.
<li>
<b>A unique web page.</b> This book does not come with a CD. CDs are expensive and cannot be
updated once they are released. Instead, we have created a companion web page,
gamemath.com. There you will be able to experience interactive demos of some of the concepts
that are the hardest to grasp from text and diagrams. You can also download the code
(including any bug fixes!) and other useful utilities, find the answers to the exercises, and
check out links to other sites concerning 3D math, graphics, and programming.
</ul>
<p>

<h3>Author's Comments</h3>
Fletch deserves 99.9% of the credit for this book. I'm responsible for goading him into more and more
informality by, for example, chronicling the invention of the natural numbers by counting dead sheep,
and adding obscure Douglas Adams references. As a result this book is loved by its intended audience and
hated by my mathematically inclined colleagues. Fletch was concerned about this, but I am not:
My job here is done.
</div>

<h2>Introduction to Computer Game Programming with DirectX 8.0 (2001)</h2>

<div class=content>
<img class=centered alt="DX8 book image." src="../research/education/images/dx8strip.jpg">
<p>

<a href="/">Ian Parberry</a>, 
<em>Introduction to Computer Game Programming with DirectX 8.0</em>, Wordware Publishing, 2001. 
<p>

<h3>From Read This First</h3>

Have I got your attention yet? "Read this First" reminds me of the purchase of
my first home computer in the 1980s. It came with no less than seven documents
that said "Read This First" in big bold letters at the top of the page and they all
threatened dire consequences if I failed to do the things listed on that particular
piece of paper first . I did my best to follow the instructions, but bad things
happened anyway. I suspect that bad things would have happened no matter
what I did.
<p>

Such is not the case for this book. Browsing this chapter will, however, help
you to get started on the right foot.
<p>

Does This Look Familiar?
<p>

This book is a short, inexpensive version of the author's book Learn Computer
Game Programming with DirectX 7.0. If you already own that book, then don't buy
this one. The difference between that book and this is that:
<ul>
<li>
This book does not contain Chapters 13-15.
<li>
This book does not have the code listings at the end of each chapter. Instead,
they are included in a pdf supplement on the companion CD.
<li>
This book has three new appendices.
<li>
This book includes the recently released DirectX 8.0 SDK on the CD instead
of the DirectX 7.0a SDK.
</ul>
<p>

Are You Reading This in the Bookstore?
<p>

Are you reading this while standing in the bookstore trying to decide whether to
buy this book? If you are, then this section is written just for you. Sit on the floor
for a few minutes while I explain what it's all about and how purchasing this book
can help you get your start in the computer game industry. If you are in one of
those wonderful bookstores that have plush chairs and actually encourage you to
sit and browse through the books, you may as well make yourself comfortable
instead of skulking in the aisles getting in the way of other customers. A cup of
coffee might go down well too. My writing style is highly caffeinated. Just don't
spill any on the pages.
<p>

I assume that you picked up this book and opened it because you are an aspiring
game programmer and the title looked appealing, not because you are male and
"Melanie Cambron, Game Recruiting Goddess" sounded attractive. Well, maybe a
little of both. Let me tell you right now that she is intelligent and very good at
what she does, which is find employees for game companies. If you haven't read
her foreword already, I recommend that you do it right now. It contains sensible
advice about getting started in the game industry, and a picture of Melanie. Have
you done it yet? Good. Now that we've satisfied our curiosity, let's take a more
serious look at what this book has to offer.
<p>

First, let me tell you what this book is not.
<p>

Most DirectX books fall into two categories. Some attempt an encyclopedic coverage
of the DirectX API, describing all of the possible permutations of all of the
awesome and confusing choices of parameters of almost every DirectX function.
You can spot those books by their huge tables listing functions and parameters-
tables that often look as if they were cut-and-pasted directly from the
DirectX documentation. This book is not like that. It assumes that you are smart
enough to look up parameters yourself using the DirectX online help.
<p>

The second category of DirectX books gives you a monolithic game engine,
essentially a wrapper for the DirectX API, that you can use to make a game of your
own. They plunk this huge piece of code "thunk" on the table, and then explain
how to go about making it work for you. It is usually a piece of code that attempts
to be all things to all people, and even though it contains more than you need to
know to get started, it may not end up being exactly what you need. This book is
not like that. It assumes that you want to write your own code from the ground up,
not customize somebody else's engine.
<p>

There is nothing wrong with either of these approaches. I have both kinds of
books on my bookshelf. The approach that I take in this book, however, is different.
It is the product of seven years of teaching game programming to students of computer
 science at the University of North Texas. Typically, those students are smart
enough to read the documentation that comes with the DirectX SDK, and smart
enough to experiment with the code samples. The problem is, all that information
is fragmentary and overwhelming in its complexity. There's just so much information
that it's hard to know where to begin.
<p>

That's where my class comes in. I teach using a series of game demos for a
side-scroller called Ned's Turkey Farm. Each demo adds a new feature or set of features
 onto the previous one, much as a real game is developed. Thus, the class is
as much about the process of coding a game as it is about DirectX.
<p>

This book is designed to give you a taste of the same experience without having
to come to Texas. Admittedly, you lose out on the other things that my class would
give you-including the experience of hanging out in my lab and the opportunity to
work on a game demo in a group with other programming and art students, but
there's not much we can do about that. I will go through the code function by function,
line by line, explaining what I am doing and why I am doing it. There's
nothing cut-and-pasted from the DirectX documentation, and I won't ever assume
that you are a dummy or an idiot. If this sounds good to you, then go ahead and buy
this book.
<p>


<h3>Author's Comments</h3>
The publishing company asked for a slimmer version of the DirectX 7 version of this book,
and along the way asked me to update it to DirectX 8. I did, but using legacy code, which
 led to mostly bad reviews
in spite of my clear warnings in the Preface.
</div>

<h2 id="dx7book">Learn Computer Game Programming with DirectX 7.0 (2000)</h2>

<div class=content>
<img class=centered alt="DX7 book image." src="../research/education/images/dx7strip.jpg">
<p>

<a href="/">Ian Parberry</a>, 
<em>Learn Computer Game Programming with DirectX 7.0</em>, Wordware Publishing, 2000.
(See also the <a href="melanie.pdf">Foreword</a> by Melanie Cambron, Game Recruiting Goddess.)

<h3>Preface</h3>

I am constantly amazed by the politeness of students
in Texas. Not one of the students in my game
programming classes has ever, in seven years,
asked me the obvious question, which is, "Who are
you, and what makes you think that you know anything
about game programming?" with its equally
obvious corollary, "If you're so good, why aren't you
out in the game industry earning the Big Bucks?"
The answers to those questions apply to you, the
reader, too. Why should you buy a book on game
programming from just anybody?
<p>

Before I answer, let me digress and tell you how I
got into game programming. In 1993 I was going
through what in academic circles passes for a
midlife crisis. In the business world, the recognized
panacea for men who go through midlife crises usually involves a red sports car
and a young trophy wife. In academia we rarely have enough money or panache for
the red sports car and the trophy wife, but we have coping strategies of our own.
Part of the typical midlife crisis involves questioning who we are and what we
are doing in life. The academic midlife crisis sometimes involves questioning the
validity of the typical academic lifestyle, which for a computer scientist like myself
involves doing research, publishing the results of that research in scientific journals,
and getting grants from federal funding agencies to do more research. Oh, and
we teach too.
<p>

I had a lot of experience doing all of the above. But that "Oh, and we teach too"
attitude was beginning to bother me. And the rising pace of the computer industry,
the way it was beginning to transform the economy, and everything about modern
life was beginning to bother me. Actually, it was more the fact that computer science
as taught at universities just didn't get it, and our students knew it that it
didn't get it. We were beginning to see entering college the crest of what was once
called the Nintendo generation, the generation of kids for whom computers were a
normal fixture of everyday life, as much as a microwave oven or a CD player was
to the previous generation. This generation thinks nothing of reformatting their
hard drive and installing a new operating system, a process that is still beyond the
reach of many Ph.D.-bearing professors of computer science. And yet computer
science in college was - and mostly still is - being taught much the way it was
taught in the 1970s. The excuse that most academics give is that we are teaching
"fundamentals," and leave the cutting-edge aspects of computer science to
on-the-job training. "Give them a firm foundation of fundamentals," they say, "And
the students will be able to learn the tools they need to get a job."
<p>

During my midlife crisis, I underwent what is euphemistically called a paradigm
shift. I changed from being a card-carrying theoretician who always quoted the
party line on college education to holding the following belief: While I agree that
students need a firm grasp of the fundamentals of computer science, I believe that
it is now no longer enough. The tools of the trade that they will be using on the job
have become too large and too sophisticated, and there are just too many of them
to leave it all to "on-the-job-training" (making it Somebody Else's Problem) after
college. Students have the right to training in fundamentals, and to have those fundamentals
illustrated on at least one real-world application using the same tools
and techniques that they will be using in their first job, weeks or days after they
graduate.
<p>

This poses a challenge for academia. The tools that programmers use change
too quickly. Academics don't like to change what they teach, and for good reason.
State legislators seem to believe that the average academic is basically lazy, so we
are allowed very little time for the preparation of new material. Developing new
classes takes time. Computer science professors are typically burned by this
already, as they must revamp most of their classes every few years. The prospect
of doing this every semester is frightening.
<p>

Nonetheless, I was coming to the conclusion that some of us need to do it. We
owe it to our students. I was (and still am) under no illusion that I can change academia
 by talking and writing papers about the phenomenon. Instead, I chose to
lead by example - I would just go ahead and do it. After all, I have tenure, and the
concept of academic freedom, the freedom of a professor to develop his or her own
vision of education, is strong at the University of North Texas.
<p>

The question was, what area of computer science should I apply my grandiose
scheme to? There are just too many areas to choose from. It should be something
new and different, something that captures the imagination of students, territory
that is largely untrodden by academic feet. One evening, with these kinds of
thoughts on my mind I walked by the General Access Computer Lab on my way
out of the building and noticed that the usual group of students playing games was
absent. Instead, there was a sign on the wall saying something like "The Playing of
Games in the General Access Lab is Banned." This kind of "Dilbert Decision" is
one that always annoys me - a rule made by administrators to make their lives easy.
The desired result is to make sure that students don't play games when other students
are waiting in line for computers to finish their homework assignments, but
it is so much easier to ban games altogether than to constantly have to confront
students who either by accident or design continue playing into busy periods.
<p>

This dislike of arbitrary rules and a general feeling of restlessness drove me to
talk to some of these students who seemed addicted to games. After a few minutes'
conversation, I quickly learned that, more than playing games, these students
wanted to write their own games. The problem was, in 1993 there was almost no
published material on game programming - almost no books, and no information on
the fledgling World Wide Web. That was a "Eureka!" moment for me. I had found
my niche. With hubris typical of a theoretician, I signed up to teach an experimental
course on game programming, with the idea that the students would help me
research the area and we would learn together. The course was a wild success, and
the rest, as they say, is history. The class became more formal and got its own
course code, and now my game laboratory is recognized as one of the premier
places in the country to learn game programming.
<p>

Since then, I have written and published several games and trained hundreds of
students in game programming, the very best of whom have gone on to become
successful game programmers in major corporations. I have over 16 years of experience
 as a professor and seven years of experience in teaching game
programming. I know how to teach a class, and I know how to structure a book so
that people can actually learn from it. That's who I am, and what makes me think I
can write a book on game programming.
<p>


<h3>Author's Comments</h3>

This book sold quite well, over 10,000 copies in fact.
<p>
The kids in the General Access Lab that I mentioned above were
playing <a href="http://en.wikipedia.org/wiki/Dune_2">Dune 2</a>.
This was an early RTS released in 1992. The students were interested in how the
motion planning worked when they clicked on a unit and sent it to the other side of the map,
in particular how they managed to make it work in real time for multiple units simultaneously
while rendering at over 24FPS on a 66MHz <a href="http://en.wikipedia.org/wiki/Intel_80486">486DX2</a>,
and why units would sometimes but not always get trapped in cul-de-sacs.
That's when it hit me. That was <a href="http://en.wikipedia.org/wiki/A*_search_algorithm">A*</a> in action. These kids wanted to learn A* to use it in games, not as a boring
old CS class. That's what got me so excited about teaching game development.
</div>


<h2>Problems on Algorithms (1995)</h2>

<div class=content>
<img class=centered alt="Thumbnails." src="../research/cseducation/images/poastrip.jpg">
<p>

<a href="/">Ian Parberry</a>, 
<cite>Problems on Algorithms</cite>, Prentice Hall, 1995.
<p>

<h3>From the Preface</h3>

The ability to devise effective and efficient algorithms in new situations
is a skill that separates the master programmer from the merely adequate coder.
The best way to develop that skill is to solve problems.
To be effective problem solvers, master-programmers-in-training must
do more than memorize a collection of standard techniques and applications
- they must in addition be able to internalize and integrate what they have
learned and apply it in new circumstances.
This book is a collection of problems on the design, analysis,
and verification of algorithms for use
by practicing programmers who wish to hone and expand their skills,
as a supplementary text for students enrolled in an
undergraduate or beginning graduate class on algorithms, and
as a self-study text
for graduate students who are preparing for the qualifying (often
called "breadth" or "comprehensive") examination on algorithms for
a Ph.D. program in Computer Science or Computer Engineering.
It is intended to augment the problem sets
found in any standard algorithms textbook.
</div>

<h2>Circuit Complexity and Neural Networks (1994)</h2>

<div class=content>

<img src="../research/neuralnets/images/ccnnstrip.png" alt="Images from Book">

<p>

<a href="/">Ian Parberry</a>,
<em>Circuit Complexity and Neural Networks</em>, MIT Press, 1994.
<p>

<h3>From the Preface</h3>

One of the basic problems with neural networks is that they do not always scale well.
Early research has shown that they work adequately on small problems (those with a
small amount of input data), but when they are scaled up to larger problems they often
need more neurons than current technology can provide or take more time than users
are willing to wait. The standard defense against this criticism is that technology is
constantly improving, so it will eventually catch up with our needs. However, our needs
are not static: as time progresses we will want to solve larger and larger problems.
The important question is how well neural networks scale, that is, how fast does the
computation time and number of neurons grow as the problem size increases. If they
grow too fast, then it may not be feasible to expect that advances in technology can keep
pace.
<p>

The number of neurons and running time of neural networks are examples of computational resources.
Others include memory and hardware in conventional computers. The
study of how the demand for computational resources scales with problem size dates from
the 1960s with the seminal paper of Hartmanis and Stearns.  This area of research
is called computational complexity theory, and is one of the richest
fields of theoretical
computer science. The aim of this book is the examination of how neural networks scale
using, for the most part, a branch of computational complexity theory known as circuit
complexity.
<p>

The reader will notice that the majority of the material in this book is on computation
by neural networks as opposed to learning, which is slightly unusual since the balance in
the technical literature is tipped in the other direction. Neural network computation is
a necessary part of the foundations of neural network learning. Just as a child cannot
learn to perform a task unless he or she is physically capable of performing it, a neural
network cannot learn to compute a function unless it is physically capable of computing it.
"Physically capable"
 in this context means "possessing sufficient resources",
in particular,
enough neurons and time.
Although this book is aimed at an audience interested in neural networks, some of
it consists of background material about computational complexity theory as it applies
to conventional computers. This is included because one of the aims of this book is
to make a comparison between the complexity of neural networks and the complexity
of conventional computers. This comparison is meaningless unless the reader knows
something about the latter. I have attempted to present the background in as palatable
a form as possible for neural networkers. For example, I have avoided all talk of Turing
machines and nondeterminism. Instead, circuit complexity has been used throughout as
a unifying theme.
<p>
 

<h3>Author's Comment</h3>
I remember the editor at MIT Press being annoyed that the manuscript I turned in was a lot
shorter and did not contain what he was expecting. I had to argue quite a lot before they
would go ahead and publish it. It <a href="http://scholar.google.com/citations?view_op=view_citation&amp;hl=en&amp;user=8ZpdXNcAAAAJ&amp;citation_for_view=8ZpdXNcAAAAJ:u5HHmVD_uO8C">has
been cited well over the years</a>, so I guess I was right.
</div>

<h2>Parallel Complexity Theory (1987)</h2>

<div class=content>
  <img class="centered" src="../research/parallel/images/pctstrip.jpg" alt="Images from Book">
<p>

  <a href="/">Ian Parberry</a>,
  <em>Parallel Complexity Theory</em>, in series Research Notes in Theoretical Computer Science, (R. V. Book, Ed.),
  Pitman Press, London, 1987.
<p>

<h3>From the Preface</h3>

Parallel complexity theory, the study of resource-bounde
parallel computation, is surely one of the fastest-growin
areas of theoretical Computer Science
In the light of this, it would be foolish to attemp
an encyclopedic coverage of the field.  However
it is the belief of the author that its foundation
are becoming increasingly clear and well-defined.  This Monograp
is an attempt to present these foundations in a unified an
coherent manner
<p>

The material contained herei
is aimed at advanced Graduate students or researcher
in theoretical Computer Science who wish to gain an insight into paralle
complexity theory.  It is assumed that the reader has (in addition t
a certain level of mathematical maturity
a general knowledge of Computer Science
and familiarity with automata theory, formal languages
complexity theory and analysis of algorithms.
<p>


<h3>Author's Comments</h3>
This is the book version of my thesis with a few additions, including an integer version
of Mike Paterson's treatment of the AKS sorting network.
</div>

<div class=updateinfo>
  <p>
    Created May 1, 2012.
    Last updated August 3, 2019.
  </p>
</div>
</body>
</html>
